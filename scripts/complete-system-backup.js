#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import dotenv from 'dotenv';
import logger from '../src/utils/logger.js';
import DatabaseBackup from './backup-database.js';

const execAsync = promisify(exec);
dotenv.config();

/**
 * Sistema de backup completo - inclui aplica√ß√£o, dados, configura√ß√µes e logs
 */
class CompleteSystemBackup {
    constructor() {
        this.projectRoot = process.cwd();
        this.backupDir = path.join(this.projectRoot, 'backups');
        this.systemBackupDir = path.join(this.backupDir, 'system');
        this.maxBackups = 10;
        this.timestamp = new Date().toISOString()
            .replace(/[:.]/g, '-')
            .replace('T', '_')
            .split('.')[0];
        
        // Diret√≥rios e arquivos para backup
        this.criticalPaths = [
            // C√≥digo fonte
            'src/',
            'public/',
            'scripts/',
            
            // Configura√ß√µes
            'config/',
            'package.json',
            'package-lock.json',
            '.env.example',
            'nodemon.json',
            'eslint.config.js',
            
            // Dados
            'data/',
            'logs/',
            
            // Documenta√ß√£o
            'docs/',
            'README.md',
            'SETUP_REAL_DATA.md',
            'GUIA_USUARIO_ADMIN.md',
            
            // Ferramentas
            'matriz-cli.py',
            
            // Obsidian integration
            'obsidian-sync/'
        ];
        
        // Arquivos a serem exclu√≠dos
        this.excludePaths = [
            'node_modules/',
            'backups/',
            'cert/',
            '.git/',
            '*.log',
            'tmp/',
            '.env'  // N√£o incluir arquivo de ambiente atual por seguran√ßa
        ];
    }

    /**
     * Criar estrutura de diret√≥rios de backup
     */
    ensureBackupStructure() {
        const dirs = [
            this.backupDir,
            this.systemBackupDir
        ];
        
        dirs.forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
                logger.info(`üìÅ Diret√≥rio criado: ${path.relative(this.projectRoot, dir)}`);
            }
        });
    }

    /**
     * Gerar nome √∫nico para o backup
     */
    generateBackupName() {
        return `system_backup_${this.timestamp}`;
    }

    /**
     * Copiar arquivo ou diret√≥rio recursivamente
     */
    async copyPath(source, destination) {
        try {
            const stats = fs.statSync(source);
            
            if (stats.isDirectory()) {
                // Criar diret√≥rio de destino
                if (!fs.existsSync(destination)) {
                    fs.mkdirSync(destination, { recursive: true });
                }
                
                // Copiar conte√∫do do diret√≥rio
                const items = fs.readdirSync(source);
                for (const item of items) {
                    const sourcePath = path.join(source, item);
                    const destPath = path.join(destination, item);
                    
                    // Verificar se n√£o est√° na lista de exclus√µes
                    const relativePath = path.relative(this.projectRoot, sourcePath);
                    const shouldExclude = this.excludePaths.some(exclude => 
                        relativePath.includes(exclude.replace('*', '')) ||
                        relativePath.endsWith(exclude.replace('*.', '.'))
                    );
                    
                    if (!shouldExclude) {
                        await this.copyPath(sourcePath, destPath);
                    }
                }
            } else {
                // Copiar arquivo
                fs.copyFileSync(source, destination);
            }
        } catch (error) {
            logger.warn(`‚ö†Ô∏è Erro ao copiar ${source}: ${error.message}`);
        }
    }

    /**
     * Fazer backup da aplica√ß√£o
     */
    async backupApplication(backupPath) {
        try {
            logger.info('üì¶ Fazendo backup da aplica√ß√£o...');
            
            const appBackupPath = path.join(backupPath, 'application');
            fs.mkdirSync(appBackupPath, { recursive: true });
            
            // Copiar arquivos e diret√≥rios cr√≠ticos
            for (const criticalPath of this.criticalPaths) {
                const sourcePath = path.join(this.projectRoot, criticalPath);
                
                if (fs.existsSync(sourcePath)) {
                    const destPath = path.join(appBackupPath, criticalPath);
                    await this.copyPath(sourcePath, destPath);
                    logger.info(`  ‚úÖ ${criticalPath}`);
                } else {
                    logger.warn(`  ‚ö†Ô∏è N√£o encontrado: ${criticalPath}`);
                }
            }
            
            logger.success('‚úÖ Backup da aplica√ß√£o conclu√≠do');
            return appBackupPath;
        } catch (error) {
            logger.error('‚ùå Erro no backup da aplica√ß√£o:', error.message);
            throw error;
        }
    }

    /**
     * Fazer backup do banco de dados
     */
    async backupDatabase(backupPath) {
        try {
            logger.info('üóÑÔ∏è Fazendo backup do banco de dados...');
            
            const dbBackup = new DatabaseBackup();
            const dbBackupPath = await dbBackup.performBackup();
            
            // Mover backup do DB para a estrutura do backup completo
            const systemDbPath = path.join(backupPath, 'database');
            
            if (fs.existsSync(dbBackupPath)) {
                // Copiar backup do DB para a estrutura do sistema
                await this.copyPath(dbBackupPath, systemDbPath);
                logger.success('‚úÖ Backup do banco de dados inclu√≠do');
            }
            
            return systemDbPath;
        } catch (error) {
            logger.error('‚ùå Erro no backup do banco de dados:', error.message);
            throw error;
        }
    }

    /**
     * Backup das configura√ß√µes do sistema
     */
    async backupSystemConfig(backupPath) {
        try {
            logger.info('‚öôÔ∏è Fazendo backup das configura√ß√µes...');
            
            const configBackupPath = path.join(backupPath, 'system-config');
            fs.mkdirSync(configBackupPath, { recursive: true });
            
            // Informa√ß√µes do sistema
            const systemInfo = {
                timestamp: new Date().toISOString(),
                nodeVersion: process.version,
                platform: process.platform,
                arch: process.arch,
                hostname: require('os').hostname(),
                backupVersion: '2.0.0',
                projectVersion: this.getProjectVersion(),
                environment: {
                    NODE_ENV: process.env.NODE_ENV || 'development',
                    PORT: process.env.PORT || '3000'
                }
            };
            
            fs.writeFileSync(
                path.join(configBackupPath, 'system-info.json'),
                JSON.stringify(systemInfo, null, 2)
            );
            
            // Backup das depend√™ncias
            if (fs.existsSync(path.join(this.projectRoot, 'package.json'))) {
                const packageJson = JSON.parse(
                    fs.readFileSync(path.join(this.projectRoot, 'package.json'), 'utf8')
                );
                
                fs.writeFileSync(
                    path.join(configBackupPath, 'dependencies.json'),
                    JSON.stringify({
                        dependencies: packageJson.dependencies || {},
                        devDependencies: packageJson.devDependencies || {},
                        scripts: packageJson.scripts || {},
                        engines: packageJson.engines || {}
                    }, null, 2)
                );
            }
            
            // Informa√ß√µes do Git (se dispon√≠vel)
            try {
                const { stdout: gitBranch } = await execAsync('git branch --show-current');
                const { stdout: gitCommit } = await execAsync('git rev-parse HEAD');
                const { stdout: gitStatus } = await execAsync('git status --porcelain');
                
                const gitInfo = {
                    branch: gitBranch.trim(),
                    commit: gitCommit.trim(),
                    hasUncommittedChanges: gitStatus.trim().length > 0,
                    status: gitStatus.trim().split('\n').filter(line => line.trim())
                };
                
                fs.writeFileSync(
                    path.join(configBackupPath, 'git-info.json'),
                    JSON.stringify(gitInfo, null, 2)
                );
            } catch (gitError) {
                logger.warn('‚ö†Ô∏è Informa√ß√µes do Git n√£o dispon√≠veis');
            }
            
            logger.success('‚úÖ Backup das configura√ß√µes conclu√≠do');
            return configBackupPath;
        } catch (error) {
            logger.error('‚ùå Erro no backup das configura√ß√µes:', error.message);
            throw error;
        }
    }

    /**
     * Obter vers√£o do projeto
     */
    getProjectVersion() {
        try {
            const packagePath = path.join(this.projectRoot, 'package.json');
            if (fs.existsSync(packagePath)) {
                const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                return packageJson.version || '1.0.0';
            }
        } catch (error) {
            logger.warn('‚ö†Ô∏è N√£o foi poss√≠vel obter vers√£o do projeto');
        }
        return 'unknown';
    }

    /**
     * Criar arquivo de metadados do backup
     */
    createBackupMetadata(backupPath, components) {
        try {
            const metadata = {
                timestamp: new Date().toISOString(),
                backupType: 'complete-system',
                version: '2.0.0',
                projectVersion: this.getProjectVersion(),
                platform: process.platform,
                nodeVersion: process.version,
                components: components,
                paths: this.criticalPaths,
                excluded: this.excludePaths,
                backupSize: this.calculateBackupSize(backupPath),
                integrity: {
                    checksum: this.generateChecksum(backupPath),
                    fileCount: this.countFiles(backupPath)
                }
            };
            
            const metadataPath = path.join(backupPath, 'backup-metadata.json');
            fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
            
            // Criar arquivo README para o backup
            const readmePath = path.join(backupPath, 'BACKUP-README.md');
            const readmeContent = this.generateBackupReadme(metadata);
            fs.writeFileSync(readmePath, readmeContent);
            
            logger.success('üìã Metadados do backup criados');
            return metadata;
        } catch (error) {
            logger.warn('‚ö†Ô∏è Erro ao criar metadados:', error.message);
            return null;
        }
    }

    /**
     * Gerar README para o backup
     */
    generateBackupReadme(metadata) {
        return `# Backup Completo do Sistema Matriz

## Informa√ß√µes do Backup

- **Data/Hora**: ${new Date(metadata.timestamp).toLocaleString('pt-BR')}
- **Tipo**: ${metadata.backupType}
- **Vers√£o do Backup**: ${metadata.version}
- **Vers√£o do Projeto**: ${metadata.projectVersion}
- **Plataforma**: ${metadata.platform}
- **Node.js**: ${metadata.nodeVersion}
- **Tamanho**: ${metadata.backupSize}
- **Arquivos**: ${metadata.integrity.fileCount}

## Componentes Inclu√≠dos

${metadata.components.map(comp => `- ‚úÖ ${comp}`).join('\n')}

## Estrutura do Backup

\`\`\`
backup/
‚îú‚îÄ‚îÄ application/           # C√≥digo fonte completo
‚îÇ   ‚îú‚îÄ‚îÄ src/              # C√≥digo principal
‚îÇ   ‚îú‚îÄ‚îÄ public/           # Arquivos p√∫blicos
‚îÇ   ‚îú‚îÄ‚îÄ scripts/          # Scripts utilit√°rios
‚îÇ   ‚îî‚îÄ‚îÄ config/           # Configura√ß√µes
‚îú‚îÄ‚îÄ database/             # Backup do MongoDB
‚îú‚îÄ‚îÄ system-config/        # Configura√ß√µes do sistema
‚îú‚îÄ‚îÄ backup-metadata.json  # Metadados deste backup
‚îî‚îÄ‚îÄ BACKUP-README.md      # Este arquivo
\`\`\`

## Como Restaurar

### 1. Restaurar Aplica√ß√£o
\`\`\`bash
# Copiar arquivos da aplica√ß√£o
cp -r application/* /caminho/destino/

# Instalar depend√™ncias
npm install
\`\`\`

### 2. Restaurar Banco de Dados
\`\`\`bash
# Usar o script de restaura√ß√£o
npm run backup:restore <nome-do-backup-db>

# Ou manualmente:
mongorestore --drop database/
\`\`\`

### 3. Configurar Ambiente
\`\`\`bash
# Criar arquivo .env baseado no .env.example
cp .env.example .env

# Editar configura√ß√µes necess√°rias
nano .env
\`\`\`

### 4. Verificar Restaura√ß√£o
\`\`\`bash
# Verificar sa√∫de do sistema
npm run health

# Iniciar aplica√ß√£o
npm start
\`\`\`

## Verifica√ß√£o de Integridade

- **Checksum**: ${metadata.integrity.checksum}
- **Total de Arquivos**: ${metadata.integrity.fileCount}

## Suporte

Para mais informa√ß√µes sobre restaura√ß√£o, consulte:
- SETUP_REAL_DATA.md
- GUIA_USUARIO_ADMIN.md
- scripts/restore-database.js

---
Backup criado automaticamente pelo Sistema Matriz
`;
    }

    /**
     * Calcular tamanho do backup
     */
    calculateBackupSize(backupPath) {
        try {
            const { stdout } = require('child_process').execSync(`du -sh "${backupPath}"`);
            return stdout.trim().split('\t')[0];
        } catch (error) {
            return 'unknown';
        }
    }

    /**
     * Gerar checksum simples do backup
     */
    generateChecksum(backupPath) {
        try {
            const crypto = require('crypto');
            const hash = crypto.createHash('md5');
            
            // Usar timestamp e alguns metadados para checksum
            const data = `${this.timestamp}-${backupPath}-${Date.now()}`;
            hash.update(data);
            
            return hash.digest('hex');
        } catch (error) {
            return 'unknown';
        }
    }

    /**
     * Contar arquivos no backup
     */
    countFiles(backupPath) {
        try {
            let count = 0;
            
            const countRecursive = (dir) => {
                const items = fs.readdirSync(dir);
                for (const item of items) {
                    const itemPath = path.join(dir, item);
                    const stats = fs.statSync(itemPath);
                    
                    if (stats.isDirectory()) {
                        countRecursive(itemPath);
                    } else {
                        count++;
                    }
                }
            };
            
            countRecursive(backupPath);
            return count;
        } catch (error) {
            return 0;
        }
    }

    /**
     * Executar backup completo do sistema
     */
    async performCompleteBackup() {
        try {
            const startTime = Date.now();
            logger.info('üöÄ Iniciando backup completo do sistema...');
            
            // Criar estrutura de backup
            this.ensureBackupStructure();
            
            // Criar diret√≥rio para este backup
            const backupName = this.generateBackupName();
            const backupPath = path.join(this.systemBackupDir, backupName);
            fs.mkdirSync(backupPath, { recursive: true });
            
            logger.info(`üìÅ Backup ser√° salvo em: ${path.relative(this.projectRoot, backupPath)}`);
            
            // Componentes do backup
            const components = [];
            
            // 1. Backup da aplica√ß√£o
            try {
                await this.backupApplication(backupPath);
                components.push('Aplica√ß√£o (c√≥digo fonte, config, docs)');
            } catch (error) {
                logger.error('‚ùå Falha no backup da aplica√ß√£o:', error.message);
            }
            
            // 2. Backup do banco de dados
            try {
                await this.backupDatabase(backupPath);
                components.push('Banco de dados (MongoDB)');
            } catch (error) {
                logger.error('‚ùå Falha no backup do banco de dados:', error.message);
            }
            
            // 3. Backup das configura√ß√µes do sistema
            try {
                await this.backupSystemConfig(backupPath);
                components.push('Configura√ß√µes do sistema');
            } catch (error) {
                logger.error('‚ùå Falha no backup das configura√ß√µes:', error.message);
            }
            
            // 4. Criar metadados
            const metadata = this.createBackupMetadata(backupPath, components);
            
            // 5. Limpar backups antigos
            await this.cleanOldSystemBackups();
            
            const duration = Date.now() - startTime;
            const durationSeconds = (duration / 1000).toFixed(2);
            
            logger.success(`üéâ Backup completo do sistema conclu√≠do em ${durationSeconds}s`);
            logger.info(`üìÅ Localiza√ß√£o: ${path.relative(this.projectRoot, backupPath)}`);
            logger.info(`üì¶ Componentes: ${components.length}`);
            
            if (metadata) {
                logger.info(`üíæ Tamanho: ${metadata.backupSize}`);
                logger.info(`üìÑ Arquivos: ${metadata.integrity.fileCount}`);
            }
            
            return {
                success: true,
                backupPath,
                backupName,
                components,
                metadata,
                duration: durationSeconds
            };
            
        } catch (error) {
            logger.error('‚ùå Erro no backup completo:', error.message);
            throw error;
        }
    }

    /**
     * Limpar backups antigos do sistema
     */
    async cleanOldSystemBackups() {
        try {
            if (!fs.existsSync(this.systemBackupDir)) {
                return;
            }
            
            const backups = fs.readdirSync(this.systemBackupDir)
                .filter(file => file.startsWith('system_backup_'))
                .map(file => ({
                    name: file,
                    path: path.join(this.systemBackupDir, file),
                    stats: fs.statSync(path.join(this.systemBackupDir, file))
                }))
                .sort((a, b) => b.stats.mtime - a.stats.mtime);

            if (backups.length > this.maxBackups) {
                const toDelete = backups.slice(this.maxBackups);
                
                for (const backup of toDelete) {
                    fs.rmSync(backup.path, { recursive: true, force: true });
                    logger.info(`üóëÔ∏è Backup antigo removido: ${backup.name}`);
                }
                
                logger.info(`üßπ ${toDelete.length} backups antigos removidos`);
            }
        } catch (error) {
            logger.warn('‚ö†Ô∏è Erro ao limpar backups antigos:', error.message);
        }
    }

    /**
     * Listar backups completos dispon√≠veis
     */
    listSystemBackups() {
        try {
            if (!fs.existsSync(this.systemBackupDir)) {
                return [];
            }

            const backups = fs.readdirSync(this.systemBackupDir)
                .filter(file => file.startsWith('system_backup_'))
                .map(file => {
                    const backupPath = path.join(this.systemBackupDir, file);
                    const stats = fs.statSync(backupPath);
                    
                    // Tentar ler metadados
                    let metadata = null;
                    const metadataPath = path.join(backupPath, 'backup-metadata.json');
                    if (fs.existsSync(metadataPath)) {
                        try {
                            metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
                        } catch (error) {
                            // Ignorar erro de metadados
                        }
                    }
                    
                    return {
                        name: file,
                        path: backupPath,
                        created: stats.mtime,
                        size: this.calculateBackupSize(backupPath),
                        metadata: metadata,
                        components: metadata ? metadata.components : []
                    };
                })
                .sort((a, b) => b.created - a.created);

            return backups;
        } catch (error) {
            logger.error('‚ùå Erro ao listar backups do sistema:', error.message);
            return [];
        }
    }

    /**
     * Verificar integridade de um backup
     */
    verifyBackupIntegrity(backupName) {
        try {
            const backupPath = path.join(this.systemBackupDir, backupName);
            
            if (!fs.existsSync(backupPath)) {
                return { valid: false, error: 'Backup n√£o encontrado' };
            }
            
            const metadataPath = path.join(backupPath, 'backup-metadata.json');
            if (!fs.existsSync(metadataPath)) {
                return { valid: false, error: 'Metadados n√£o encontrados' };
            }
            
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
            const currentFileCount = this.countFiles(backupPath);
            
            const verification = {
                valid: true,
                metadata: metadata,
                expectedFiles: metadata.integrity.fileCount,
                actualFiles: currentFileCount,
                filesMatch: currentFileCount === metadata.integrity.fileCount,
                components: metadata.components || [],
                warnings: []
            };
            
            if (!verification.filesMatch) {
                verification.warnings.push('Contagem de arquivos n√£o confere');
            }
            
            // Verificar componentes principais
            const expectedDirs = ['application', 'database', 'system-config'];
            for (const dir of expectedDirs) {
                const dirPath = path.join(backupPath, dir);
                if (!fs.existsSync(dirPath)) {
                    verification.warnings.push(`Componente ausente: ${dir}`);
                }
            }
            
            verification.valid = verification.warnings.length === 0;
            
            return verification;
        } catch (error) {
            return { 
                valid: false, 
                error: `Erro na verifica√ß√£o: ${error.message}` 
            };
        }
    }
}

// Executar backup se chamado diretamente
if (process.argv[1] === new URL(import.meta.url).pathname) {
    const systemBackup = new CompleteSystemBackup();
    
    const command = process.argv[2];
    
    switch (command) {
        case 'create':
            systemBackup.performCompleteBackup()
                .then(result => {
                    console.log(`‚úÖ Backup completo criado: ${result.backupName}`);
                    console.log(`üìÅ Localiza√ß√£o: ${result.backupPath}`);
                    console.log(`‚è±Ô∏è Dura√ß√£o: ${result.duration}s`);
                    process.exit(0);
                })
                .catch(error => {
                    console.error(`‚ùå Erro: ${error.message}`);
                    process.exit(1);
                });
            break;
            
        case 'list':
            const backups = systemBackup.listSystemBackups();
            if (backups.length === 0) {
                console.log('üìÅ Nenhum backup completo encontrado');
            } else {
                console.log('üì¶ Backups completos dispon√≠veis:');
                backups.forEach(backup => {
                    console.log(`  - ${backup.name}`);
                    console.log(`    üìÖ ${backup.created.toLocaleString()}`);
                    console.log(`    üíæ ${backup.size}`);
                    if (backup.components.length > 0) {
                        console.log(`    üìã ${backup.components.join(', ')}`);
                    }
                    console.log();
                });
            }
            break;
            
        case 'verify':
            const backupName = process.argv[3];
            if (!backupName) {
                console.log('‚ùå Nome do backup √© obrigat√≥rio');
                console.log('Uso: node scripts/complete-system-backup.js verify <nome-do-backup>');
                process.exit(1);
            }
            
            const verification = systemBackup.verifyBackupIntegrity(backupName);
            
            if (verification.valid) {
                console.log(`‚úÖ Backup ${backupName} √© v√°lido`);
                console.log(`üìÑ Arquivos: ${verification.actualFiles}`);
                console.log(`üìã Componentes: ${verification.components.join(', ')}`);
            } else {
                console.log(`‚ùå Backup ${backupName} tem problemas:`);
                if (verification.error) {
                    console.log(`   ${verification.error}`);
                }
                if (verification.warnings) {
                    verification.warnings.forEach(warning => {
                        console.log(`   ‚ö†Ô∏è ${warning}`);
                    });
                }
            }
            break;
            
        default:
            console.log(`
üè¢ Sistema de Backup Completo do Matriz

Uso:
  node scripts/complete-system-backup.js create           - Criar backup completo
  node scripts/complete-system-backup.js list             - Listar backups
  node scripts/complete-system-backup.js verify <backup>  - Verificar integridade

Exemplos:
  npm run system:backup
  npm run system:list
  npm run system:verify system_backup_2025-01-27_15-30-45

O backup completo inclui:
  - C√≥digo fonte completo (src/, public/, scripts/, config/)
  - Banco de dados MongoDB
  - Configura√ß√µes do sistema
  - Documenta√ß√£o
  - Metadados e informa√ß√µes de restaura√ß√£o
            `);
    }
}

export default CompleteSystemBackup;
